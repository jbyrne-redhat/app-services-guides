////
START GENERATED ATTRIBUTES
WARNING: This content is generated by running npm --prefix .build run generate:attributes
////


:community:
:imagesdir: ./images
:product-version: 1
:product-long: Application Services
:product: App Services
// Placeholder URL, when we get a HOST UI for the service we can put it here properly
:service-url: https://cloud.redhat.com/beta/application-services/streams/
:property-file-name: app-services.properties

// Other upstream project names
:samples-git-repo: https://github.com/redhat-developer/app-services-guides

//URL components for cross refs
:base-url: https://github.com/redhat-developer/app-services-guides/blob/main/
:base-url-cli: https://github.com/redhat-developer/app-services-cli/tree/main/docs/
:getting-started-url: getting-started/README.adoc
:kafka-bin-scripts-url: kafka-bin-scripts/README.adoc
:kafkacat-url: kafkacat/README.adoc
:quarkus-url: quarkus/README.adoc
:rhoas-cli-url: rhoas-cli/README.adoc
:rhoas-cli-ref-url: commands
:topic-config-url: topic-configuration/README.adoc

////
END GENERATED ATTRIBUTES
////

[id="chap-binding-openshift-applications"]
= Binding OpenShift applications to {product-long}
:context: service-binding

[IMPORTANT]
====
{product-long} is currently available for Development Preview. Development Preview releases provide early access to a limited set of features that might not be fully tested and that might change in the final GA version. Users should not use Development Preview software in production or for business-critical workloads. Limited documentation is available for Development Preview releases and is typically focused on fundamental user goals.
====

[role="_abstract"]
As a developer of applications and services, you can connect applications deployed on a Kubernetes platform such as Red Hat OpenShift to Kafka instances created in {product-long}.

For example, suppose you've the following applications deployed on OpenShift:

* One application that publishes price updates for a variety of stocks
* A second application that consumes the price updates for publication on a web page

In addition, you've a Kafka instance in {product}. Each time the first application produces a price update, you want to use the Kafka instance to forward the update as an event to the second, consuming application.

To achieve this behavior, you need a way to connect the applications in OpenShift to your Kafka instance in {product}. In {product}, using an Operator to provide an application on Kubernetes with the parameters required to connect to a Kafka instance is called __service binding__.

This guide describes how to use the Red Hat OpenShift Application Services (RHOAS) Operator to perform service binding for {product}. The Kubernetes platform referred to in the remainder of this guide is Red Hat OpenShift.


[id="con-about-service-binding-using-rhoas-operator_{context}"]
== About service binding using the RHOAS Operator

In {product}, using an Operator to provide an application on OpenShift with the parameters required to connect to a Kafka instance is called __service binding__. To perform service binding for {product}, you use the Red Hat OpenShift Application Services (RHOAS) Operator.

The RHOAS Operator enables you to expose a Kafka instance created in {product} to applications deployed on OpenShift. You can use commands in the RHOAS CLI that instruct the RHOAS Operator to inject connection parameters for a specified Kafka instance to an application running on OpenShift. With connection between your application and Kafka instance established, you can then work directly with the Kafka instance using standard OpenShift features and APIs.

When you bind a Kafka instance with an OpenShift application, the RHOAS Operator injects connection parameters as files into the Pod for your application. The RHOAS Operator creates the following directory and file structure in the application Pod:

[source, subs="+quotes"]
----
/bindings/__<kafka-instance-name>__
├── bootstrapServers
├── password
├── provider
├── saslMechanism
├── securityProtocol
├── type
└── user
----

Each file that the RHOAS Operator injects into the application Pod contains a single connection parameter, specified in plain text. The connection parameters that correspond to the injected files are described below.

bootstrapServers:: Bootstrap server endpoint for the Kafka instance.
password:: Password for connection to the Kafka instance.
provider:: Cloud provider for the Kafka instance.
saslMechanism:: Simple Authentication and Security Layer (SASL) mechanism used by the Kafka instance for client authentication.
securityProtocol:: Protocol used by the Kafka instance to secure client connections.
type:: Metadata that identifies the Red Hat OpenShift Application Services (RHOAS) service. For a Kafka instance in {product}, this is set to a value of `kafka`.
user:: User name for connection to the Kafka instance.

[id="proc-installing-rhoas-operator_{context}"]
== Installing the RHOAS Operator on OpenShift

[role="_abstract"]
Before you can bind Kafka instances in {product-long} to applications in OpenShift, you need to install the Red Hat OpenShift Application Services (RHOAS) Operator. The following procedure shows how to use the OperatorHub interface in the OpenShift web console to install the RHOAS Operator.

.Prerequisites
* You can access your OpenShift cluster with the `dedicated-admin` role (OpenShift Dedicated) or `cluster-admin` role.

.Procedure
. Log in to the OpenShift web console with the `dedicated-admin` role (OpenShift Dedicated) or `cluster-admin` role.
. Click the perspective switcher in the upper-left corner. Switch to the *Administrator* perspective.
. In the left menu, click *Operators* > *OperatorHub*.
. In the *Filter by keyword* field, enter `RHOAS`.
. Select the *OpenShift Application Services (RHOAS)* Operator.
. If you see a dialog box entitled *Show community Operator*, review the included information. When you've finished, click *Continue*.
+
An information sidebar for the RHOAS Operator opens.

. In the sidebar, review the information about the RHOAS Operator and click *Install*.
. On the *Install Operator* page, perform the following actions:
.. For the *Installation mode* option, ensure that `All namespaces on the cluster` is selected.
.. For the *Update channel* and *Update approval* options, keep the default values.
.. Click *Install*.
. When the installation process finishes, click *View Operator* to see the RHOAS Operator details. Alternatively, in the left menu, click *Operators* > *Installed Operators* and then click the RHOAS Operator.
+
Observe that the RHOAS Operator is installed in the `openshift-operators` namespace by default.

[id="con-binding-openshift-application-using-cli_{context}"]
== Binding an OpenShift application to {product-long} using the RHOAS CLI

When the Red Hat OpenShift Application Services (RHOAS) Operator is installed in your OpenShift cluster, you can use the RHOAS CLI to interact directly with the cluster. Specifically, you can use the CLI and RHOAS Operator to connect an application running in the cluster to a Kafka instance. In {product}, using an Operator to provide an application on OpenShift with the parameters required to connect to a Kafka instance is called __service binding__.

The following tutorial shows how to use the RHOAS CLI and RHOAS Operator to perform service binding. In the tutorial, you create an example Quarkus application and connect this to a Kafka instance. link:https://quarkus.io/[Quarkus^] is a Kubernetes-native Java framework that is optimized for serverless, cloud, and Kubernetes environments.

When you perform service binding, the RHOAS Operator injects connection parameters as files into the Pod for the application. Because the example Quarkus application uses the `quarkus-kubernetes-service-binding` link:https://quarkus.io/guides/deploying-to-kubernetes#service-binding[extension], the application automatically detects and uses the injected connection parameters.

In general, this automatic injection and detection of connection parameters eliminates the need to manually configure an application to connect to a Kafka instance in {product}. This is a particular advantage if you've many applications in your project that you want to connect to a Kafka instance.

IMPORTANT: Some steps in the tutorial require you to log in to your OpenShift cluster with the `dedicated-admin` role (OpenShift Dedicated) or `cluster-admin` role.

[id="proc-verifying-connection-to-openshift-cluster_{context}"]
=== Verifying connection to your OpenShift cluster

[role="_abstract"]
In this step of the tutorial, you verify that the installed RHOAS Operator is working by using the RHOAS CLI to connect to your OpenShift cluster and retrieve the cluster status.

.Prerequisites
* The RHOAS Operator is installed in your OpenShift cluster. See xref:proc-installing-rhoas-operator_{context}[].
* You can access your OpenShift cluster with privileges to create a new project.
* You've installed the OpenShift CLI. For more information, see link:https://docs.openshift.com/container-platform/4.7/cli_reference/openshift_cli/getting-started-cli.html#installing-openshift-cli[Installing the OpenShift CLI].
* You've installed the RHOAS CLI. For more information, see link:{base-url}{rhoas-cli-url}#proc-installing-rhoas_getting-started-rhoas[Installing the RHOAS CLI].

.Procedure
. Log in to your OpenShift cluster as a user who has privileges to create a new project.
+
[source,subs="+quotes"]
----
$ oc login -u __<user>__ -p __<password>__ --server=__<host:port>__
----
+
In the preceding example, replace the values in angle brackets (`< >`) with your own values.

. Create a new project, as shown in the following example.
+
[source, subs="+quotes"]
----
$ oc new-project rhoas-quarkus
----

. Log in to the RHOAS CLI.
+
[source]
----
$ rhoas login
----

. Use the RHOAS CLI to connect to your OpenShift cluster and retrieve the cluster status.
+
[source]
----
$ rhoas cluster status
Namespace: rhoas-quarkus
RHOAS Operator: Installed
----
+
As shown in the output, the CLI indicates that the RHOAS Operator was successfully installed. The CLI also retrieves the name of the current OpenShift project (namespace).

[id="proc-connecting-kafka-instance-to-openshift-cluster_{context}"]
=== Connecting a Kafka instance to your OpenShift cluster

[role="_abstract"]
When you've verified connection to your OpenShift cluster, you can connect a specific Kafka instance created in {product} to the current project in the cluster. In this step of the tutorial, you use the RHOAS CLI to connect a specified Kafka instance to a project in your cluster.

.Prerequisites
* You've completed the previous steps in this tutorial:
** xref:proc-verifying-connection-to-openshift-cluster_{context}[]
* You’ve created a Kafka instance in {product} and the instance is in the *Ready* state. To learn how to create a Kafka instance, see link:{base-url}{getting-started-url}[Getting started with {product-long}].
* You have an API token to connect to your Kafka instance. To get a token, see the link:https://cloud.redhat.com/openshift/token[OpenShift Cluster Manager API Token] page.

.Procedure

. If you're not already logged in to your OpenShift cluster, log in as the same user who completed the previous step of this tutorial.
+
[source, subs="+quotes"]
----
$ oc login -u __<user>__ -p __<password>__ --server=__<host:port>__
----
+
In the preceding example, replace the values in angle brackets (`< >`) with your own values.

. Ensure that the current OpenShift project is the one created in the previous step of this tutorial, as shown in the following example.
+
[source]
----
$ oc project rhoas-quarkus
----

. Connect a Kafka instance in {product} to the current project in your OpenShift cluster.
+
[source]
----
$ rhoas cluster connect --ignore-context
----
+
You're prompted to specify the Kafka instance that you want to connect to OpenShift.

. Type the name of the Kafka instance that you want to connect to OpenShift. Press *Enter*.
+
You should see output like the following:
+
[source]
----
Connection Details:

Apache Kafka instance:  my-kafka-instance
Kubernetes Namespace:   rhoas-quarkus
Service Account Secret: rh-cloud-services-service-account
----

. Verify the connection details shown by the CLI. When you're ready to continue, type `y` and then press *Enter*.
+
You're prompted to provide an access token. The RHOAS Operator requires this token to make a connection to your Kafka instance.

. In your web browser, open the link:https://cloud.redhat.com/openshift/token[OpenShift Cluster Manager API Token] page. Copy the access token shown.

. On the command line, right-click and select *Paste*. Press *Enter*.
+
The RHOAS Operator uses the token to create a `KafkaConnection` resource on your OpenShift cluster. When this process is complete, you should see lines like the following:
+
[source]
----
KafkaConnection resource "my-kafka-instance" has been created
Waiting for status from KafkaConnection resource.
Created KafkaConnection can be injected into your application.
...
KafkaConnection successfully installed on your cluster.
----

. Verify that the RHOAS Operator successfully created the connection.
+
[source]
----
$ oc get KafkaConnection

NAME   		         AGE
my-kafka-instance    2m35s
----
+
As shown in the output, the RHOAS Operator creates a `KafkaConnection` resource that matches the name of your Kafka instance. In this example, the resource name matches a Kafka instance called `my-kafka-instance`.

[id="proc-deploying-example-application-in-openshift_{context}"]
=== Deploying an example application in OpenShift

[role="_abstract"]
In this step of the tutorial, you deploy an example Quarkus application in the OpenShift project that you created earlier in the tutorial.

The Quarkus application generates random numbers between 0 and 100 and produces those numbers to a Kafka topic. Another part of the application consumes the numbers from the Kafka topic. Finally, the application uses __server-sent events__ to expose the numbers as a REST UI. A web page in the application displays the exposed numbers.

The example Quarkus application uses the `quarkus-kubernetes-service-binding` link:https://quarkus.io/guides/deploying-to-kubernetes#service-binding[extension], which means that the application automatically detects and uses the injected connection parameters. This eliminates the need for manual configuration of the application.

.Prerequisites
* You've completed the previous steps in this tutorial:
** xref:proc-verifying-connection-to-openshift-cluster_{context}[]
** xref:proc-connecting-kafka-instance-to-openshift-cluster_{context}[]
* You've privileges to deploy applications in the OpenShift project created earlier in this tutorial.

.Procedure

. If you're not already logged in to your OpenShift cluster, log in as a user who has privileges to deploy applications in the OpenShift project created earlier in this tutorial.
+
[source,subs="+quotes"]
----
$ oc login -u __<user>__ -p __<password>__ --server=__<host:port>__
----
+
In the preceding example, replace the values in angle brackets (`< >`) with your own values.

. Ensure that the current OpenShift project is the one created earlier in this tutorial, as shown in the following example.
+
[source]
----
$ oc project rhoas-quarkus
----

. To deploy the Quarkus application, apply an example application template provided by {product}.
+
[source,options="nowrap"]
----
$ oc apply -f https://raw.githubusercontent.com/redhat-developer/app-services-guides/main/code-examples/quarkus-kafka-quickstart/.kubernetes/kubernetes.yml

service/rhoas-quarkus-kafka created
deployment.apps/rhoas-quarkus-kafka created
route.route.openshift.io/rhoas-quarkus-kafka created
----
+
As shown in the output, when you deploy the application, OpenShift creates a Service and Route for access to the application.

. Get the URL of the Route created for the application.
+
[source,options="nowrap"]
----
$ oc get route

NAME                   HOST/PORT
rhoas-quarkus-kafka    rhoas-quarkus-kafka-jbyrne-dev.apps.sandbox-m2.ll9k.p1.openshiftapps.com
----

. On the command line, highlight the URL shown under *HOST/PORT*. Right-click and select *Copy*.

. In your web browser, paste the URL for the Route.
+
A web page for the Quarkus application opens.

. In your web browser, append `/prices.html` to the URL.
+
A new web page entitled *Last price* opens.  Because you haven't yet connected the Quarkus application to your Kafka instance, the price value appears as `N/A`.

[id="proc-creating-topic-in-kafka-instance_{context}"]
=== Creating a topic in your Kafka instance

[role="_abstract"]
In the previous step of this tutorial, you created an example OpenShift application. The application is a Quarkus application that uses a Kafka topic called `prices` to produce and consume messages. In this step, you create the `prices` topic in your Kafka instance so that the Quarkus application can interact with it.

.Prerequisites
* You've completed the previous steps in this tutorial:
** xref:proc-verifying-connection-to-openshift-cluster_{context}[]
** xref:proc-connecting-kafka-instance-to-openshift-cluster_{context}[]
** xref:proc-deploying-example-application-in-openshift_{context}[]
* You’ve created a Kafka instance in {product} and the instance is in the *Ready* state. To learn how to create a Kafka instance, see link:{base-url}{getting-started-url}[Getting started with {product-long}].

.Procedure
. On the link:{service-url}[Kafka Instances] page of the {product} web console, click the name of the Kafka instance that you want to add a topic to.

. Click *Create topic* and follow the guided steps to define the topic details. Click *Next* to complete each step and click *Finish* to complete the setup.
+
.Guided steps to define topic details
image::sak-create-topic.png[Image of wizard to create a topic]

*Topic name*:: Enter `prices` as the topic name.
*Partitions*:: Set the number of partitions for this topic. For this tutorial, set a value of `1`. Partitions are distinct lists of messages within a topic and enable parts of a topic to be distributed over multiple brokers in the cluster. A topic can contain one or more partitions, enabling producer and consumer loads to be scaled.
+
NOTE: You can increase the number of partitions later, but you cannot decrease them.
+
*Message retention*:: Set the message retention time to the relevant value and increment. For this tutorial, set a value of `7 days`. Message retention time is the amount of time that messages are retained in a topic before they are deleted or compacted, depending on the cleanup policy.
*Replicas*:: For this release of {product}, the replicas are preconfigured. The number of partition replicas for the topic is set to `3` and the minimum number of follower replicas that must be in sync with a partition leader is set to `2`. Replicas are copies of partitions in a topic. Partition replicas are distributed over multiple brokers in the cluster to ensure topic availability if a broker fails. When a follower replica is in sync with a partition leader, the follower replica can become the new partition leader if needed.
+
After you complete the topic setup, the new Kafka topic is listed in the topics table.

[id="proc-binding-kafka-instance-to-openshift-application_{context}"]
=== Binding your Kafka instance to your OpenShift application

In this step of the tutorial, you use the RHOAS CLI to bind your Kafka instance to your OpenShift application. When you perform this binding, the RHOAS Operator injects connection parameters as files into the Pod for the application. The Quarkus application automatically detects and uses the connection parameters to bind to the Kafka instance.

.Prerequisites
* You've completed the previous steps in this tutorial:
** xref:proc-verifying-connection-to-openshift-cluster_{context}[]
** xref:proc-connecting-kafka-instance-to-openshift-cluster_{context}[]
** xref:proc-deploying-example-application-in-openshift_{context}[]
** xref:proc-creating-topic-in-kafka-instance_{context}[]
* You understand how the RHOAS Operator injects connection parameters as files into a client application Pod. To learn more, see xref:con-about-service-binding-using-rhoas-operator_{context}[].

.Procedure
. If you're not already logged in to your OpenShift cluster, log in as a user who has privileges to deploy applications in the project created earlier in this tutorial.
+
[source, subs="+quotes"]
----
$ oc login -u __<user>__ -p __<password>__ --server=__<host:port>__
----
+
In the preceding example, replace the values in angle brackets (`< >`) with your own values.

. Ensure that the current OpenShift project is the one created earlier in this tutorial, as shown in the following example.
+
[source]
----
$ oc project rhoas-quarkus
----

. Use the RHOAS CLI to bind your Kafka instance to an application in your OpenShift project.
+
[source]
----
$ rhoas cluster bind
----
+
You're prompted to specify the Kafka instance in {product} that you want to connect to OpenShift.

. Type the name of the Kafka instance that you want to connect to OpenShift. Press *Enter*.
+
You're prompted to specify the OpenShift application that you want to bind your Kafka instance to.

. To bind to the example Quarkus application that you deployed, type `rhoas-quarkus-kafka`. Press *Enter*.

. Type `y` to confirm that you want to continue. Press *Enter*.
+
When binding is complete, you should see output like the following:
+
[source]
----
Binding my-kafka-instance with rhoas-quarkus-kafka app succeeded
----
+
The preceding output shows that the RHOAS CLI successfully bound a Kafka instance called `my-kafka-instance` to the example Quarkus application called `rhoas-quarkus-kafka` in OpenShift. The Quarkus application automatically detected the connection parameters injected by the RHOAS Operator and used them to bind with the Kafka instance.
+
When service binding is complete, OpenShift redeploys the Quarkus application. After some time, the Quarkus application starts to use the `prices` Kafka topic that you created earlier in the tutorial. One part of the Quarkus application publishes price updates to this topic, while another part of the application consumes the updates.

. To verify that the Quarkus application is using the Kafka topic, reload the *Last price* web page that you opened earlier in this tutorial.
+
On the web page, observe that the price value is continuously updated. The updates show that the Quarkus application is now using the `prices` topic in your Kafka instance to produce and consume messages that correspond to price updates.
